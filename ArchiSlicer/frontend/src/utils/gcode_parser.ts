/**
 * G-Code Parser for ArchiSlicer Simulator
 *
 * Parses G-Code generated by ArchiSlicer and converts it to
 * a sequence of instructions for the simulator.
 *
 * Coordinate System:
 * - Machine: X is vertical (up), Y is horizontal (right)
 * - Slicer/Canvas: X is horizontal (right), Y is vertical (up)
 * - Transformation: Canvas X = Machine Y, Canvas Y = Machine X
 */

import type {
  GCodeInstruction,
  ParsedGCode,
  MachineState,
} from '../types/simulator';
import { createDefaultMachineState } from '../types/simulator';

// Pen threshold: U values below this are considered "pen down"
const PEN_DOWN_THRESHOLD = 20;

// Default feedrate
const DEFAULT_DRAWING_FEEDRATE = 3000;

/**
 * Parse a G-Code string into a structured format for the simulator
 */
export function parseGCode(gcode: string): ParsedGCode {
  const lines = gcode.split('\n');
  const instructions: GCodeInstruction[] = [];

  // Machine state tracking during parsing
  const state = createDefaultMachineState();

  // Statistics
  let totalDrawingLength = 0;
  let totalTravelLength = 0;
  let pumpCount = 0;
  let drawingMoves = 0;
  let travelMoves = 0;

  // Bounds tracking
  let minX = Infinity, maxX = -Infinity;
  let minY = Infinity, maxY = -Infinity;

  // Tool tracking
  const toolsUsed = new Set<number>();

  // Cumulative time tracking
  let cumulativeTime = 0;

  // Pump detection state
  let inPumpSequence = false;

  for (let i = 0; i < lines.length; i++) {
    const lineNumber = i + 1;
    const rawLine = lines[i].trim();

    // Skip empty lines
    if (!rawLine) continue;

    // Parse the line
    const instruction = parseLine(rawLine, lineNumber, state);

    if (!instruction) continue;

    // Handle pump sequence detection (G91 followed by Z moves, then G90)
    if (instruction.type === 'set_mode') {
      if (rawLine.includes('G91')) {
        inPumpSequence = true;
      } else if (rawLine.includes('G90') && inPumpSequence) {
        inPumpSequence = false;
      }
    }

    // Detect pump action (Z moves in relative mode)
    if (inPumpSequence && instruction.type === 'move' && instruction.z !== undefined) {
      instruction.type = 'pump';
      instruction.pumpHeight = Math.abs(instruction.z);
      pumpCount++;
    }

    // Update machine state and calculate timing
    const duration = calculateDuration(instruction, state);
    instruction.estimatedDuration = duration;
    instruction.cumulativeTime = cumulativeTime;
    cumulativeTime += duration;

    // Track start/end positions for moves
    if (instruction.type === 'move' || instruction.type === 'pump') {
      instruction.startPosition = { x: state.position.x, y: state.position.y };

      // Update position
      if (instruction.x !== undefined) {
        state.position.x = state.absoluteMode ? instruction.x : state.position.x + instruction.x;
      }
      if (instruction.y !== undefined) {
        state.position.y = state.absoluteMode ? instruction.y : state.position.y + instruction.y;
      }
      if (instruction.z !== undefined) {
        state.position.z = state.absoluteMode ? instruction.z : state.position.z + instruction.z;
      }

      instruction.endPosition = { x: state.position.x, y: state.position.y };

      // Calculate distance for statistics
      if (instruction.startPosition && instruction.endPosition) {
        const dx = instruction.endPosition.x - instruction.startPosition.x;
        const dy = instruction.endPosition.y - instruction.startPosition.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (instruction.isTravel) {
          totalTravelLength += distance;
          travelMoves++;
        } else if (instruction.type === 'move') {
          totalDrawingLength += distance;
          drawingMoves++;
        }
      }

      // Update bounds (convert machine coords to canvas coords)
      const canvasX = state.position.y; // Machine Y → Canvas X
      const canvasY = state.position.x; // Machine X → Canvas Y
      if (canvasX < minX) minX = canvasX;
      if (canvasX > maxX) maxX = canvasX;
      if (canvasY < minY) minY = canvasY;
      if (canvasY > maxY) maxY = canvasY;
    }

    // Handle pen up/down
    if (instruction.type === 'pen_up') {
      state.isPenDown = false;
      state.position.u = instruction.u ?? 33;
    } else if (instruction.type === 'pen_down') {
      state.isPenDown = true;
      state.position.u = instruction.u ?? 13;
    }

    // Handle tool changes
    if (instruction.type === 'tool_change' && instruction.toolNumber !== undefined) {
      if (instruction.isGrab) {
        state.currentTool = instruction.toolNumber;
        toolsUsed.add(instruction.toolNumber);
      } else {
        state.currentTool = null;
      }
    }

    // Handle mode changes
    if (instruction.type === 'set_mode') {
      state.absoluteMode = rawLine.includes('G90');
    }

    // Update feedrate
    if (instruction.feedrate !== undefined) {
      state.feedrate = instruction.feedrate;
    }

    // Mark travel moves
    if (instruction.type === 'move') {
      instruction.isTravel = !state.isPenDown;
    }

    instructions.push(instruction);
  }

  // Handle edge case for bounds
  if (minX === Infinity) minX = 0;
  if (maxX === -Infinity) maxX = 1864;
  if (minY === Infinity) minY = 0;
  if (maxY === -Infinity) maxY = 1210;

  return {
    instructions,
    totalDuration: cumulativeTime,
    bounds: { minX, maxX, minY, maxY },
    toolChanges: Array.from(toolsUsed).sort((a, b) => a - b),
    statistics: {
      totalMoves: drawingMoves + travelMoves,
      drawingMoves,
      travelMoves,
      totalDrawingLength: Math.round(totalDrawingLength * 10) / 10,
      totalTravelLength: Math.round(totalTravelLength * 10) / 10,
      pumpCount,
    },
  };
}

/**
 * Parse a single G-Code line
 */
function parseLine(
  rawLine: string,
  lineNumber: number,
  state: MachineState
): GCodeInstruction | null {
  // Comment line
  if (rawLine.startsWith(';')) {
    return {
      type: 'comment',
      lineNumber,
      rawLine,
      estimatedDuration: 0,
      cumulativeTime: 0,
    };
  }

  // Remove inline comments
  const line = rawLine.split(';')[0].trim();
  if (!line) return null;

  // G90 - Absolute positioning
  if (line === 'G90') {
    return {
      type: 'set_mode',
      lineNumber,
      rawLine,
      estimatedDuration: 0,
      cumulativeTime: 0,
    };
  }

  // G91 - Relative positioning
  if (line === 'G91') {
    return {
      type: 'set_mode',
      lineNumber,
      rawLine,
      estimatedDuration: 0,
      cumulativeTime: 0,
    };
  }

  // G21 - Millimeter units (ignore, we always use mm)
  if (line === 'G21') {
    return null;
  }

  // M400 - Wait for moves to finish (ignore for simulation)
  if (line === 'M400') {
    return null;
  }

  // G1 - Linear move
  if (line.startsWith('G1')) {
    return parseG1(line, lineNumber, rawLine, state);
  }

  // M98 - Macro call (tool change)
  if (line.startsWith('M98')) {
    return parseM98(line, lineNumber, rawLine);
  }

  // Unknown command
  return {
    type: 'unknown',
    lineNumber,
    rawLine,
    estimatedDuration: 0,
    cumulativeTime: 0,
  };
}

/**
 * Parse a G1 linear move command
 */
function parseG1(
  line: string,
  lineNumber: number,
  rawLine: string,
  _state: MachineState
): GCodeInstruction {
  const instruction: GCodeInstruction = {
    type: 'move',
    lineNumber,
    rawLine,
    estimatedDuration: 0,
    cumulativeTime: 0,
  };

  // Parse X coordinate
  const xMatch = line.match(/X(-?\d+\.?\d*)/);
  if (xMatch) {
    instruction.x = parseFloat(xMatch[1]);
  }

  // Parse Y coordinate
  const yMatch = line.match(/Y(-?\d+\.?\d*)/);
  if (yMatch) {
    instruction.y = parseFloat(yMatch[1]);
  }

  // Parse Z coordinate
  const zMatch = line.match(/Z(-?\d+\.?\d*)/);
  if (zMatch) {
    instruction.z = parseFloat(zMatch[1]);
  }

  // Parse U coordinate (pen position)
  const uMatch = line.match(/U(-?\d+\.?\d*)/);
  if (uMatch) {
    const uValue = parseFloat(uMatch[1]);
    instruction.u = uValue;

    // Determine if this is a pen up or pen down move
    if (uValue >= PEN_DOWN_THRESHOLD) {
      instruction.type = 'pen_up';
    } else {
      instruction.type = 'pen_down';
    }
  }

  // Parse feedrate
  const fMatch = line.match(/F(\d+\.?\d*)/);
  if (fMatch) {
    instruction.feedrate = parseFloat(fMatch[1]);
  }

  return instruction;
}

/**
 * Parse an M98 macro call (tool change)
 */
function parseM98(
  line: string,
  lineNumber: number,
  rawLine: string
): GCodeInstruction {
  const instruction: GCodeInstruction = {
    type: 'tool_change',
    lineNumber,
    rawLine,
    estimatedDuration: 2000, // Tool changes take ~2 seconds
    cumulativeTime: 0,
  };

  // Parse macro path
  const pathMatch = line.match(/P"([^"]+)"/);
  if (pathMatch) {
    const macroPath = pathMatch[1];

    // Check if it's a grab_tool macro
    const grabMatch = macroPath.match(/grab_tool_(\d+)/);
    if (grabMatch) {
      instruction.toolNumber = parseInt(grabMatch[1], 10);
      instruction.isGrab = true;
    }

    // Check if it's a place_tool macro
    const placeMatch = macroPath.match(/place_tool_(\d+)/);
    if (placeMatch) {
      instruction.toolNumber = parseInt(placeMatch[1], 10);
      instruction.isGrab = false;
    }

    // move_to_drawingHeight macros don't need special handling
  }

  return instruction;
}

/**
 * Calculate the duration of an instruction in milliseconds
 */
function calculateDuration(
  instruction: GCodeInstruction,
  state: MachineState
): number {
  if (instruction.type === 'tool_change') {
    return 2000; // Tool changes take ~2 seconds
  }

  if (instruction.type === 'pump') {
    return 500; // Pump action takes ~0.5 seconds
  }

  if (instruction.type === 'pen_up' || instruction.type === 'pen_down') {
    return 100; // Pen movements are quick
  }

  if (instruction.type === 'move') {
    // Calculate distance
    let dx = 0, dy = 0;

    if (instruction.x !== undefined) {
      const targetX = state.absoluteMode ? instruction.x : state.position.x + instruction.x;
      dx = targetX - state.position.x;
    }

    if (instruction.y !== undefined) {
      const targetY = state.absoluteMode ? instruction.y : state.position.y + instruction.y;
      dy = targetY - state.position.y;
    }

    const distance = Math.sqrt(dx * dx + dy * dy);

    // Get feedrate (mm/min)
    const feedrate = instruction.feedrate ?? state.feedrate ?? DEFAULT_DRAWING_FEEDRATE;

    // Calculate time: distance (mm) / feedrate (mm/min) * 60000 (ms/min)
    if (feedrate > 0 && distance > 0) {
      return (distance / feedrate) * 60000;
    }
  }

  return 0;
}

/**
 * Get instructions up to a specific time
 */
export function getInstructionsUpToTime(
  instructions: GCodeInstruction[],
  time: number
): GCodeInstruction[] {
  const result: GCodeInstruction[] = [];

  for (const instruction of instructions) {
    if (instruction.cumulativeTime > time) break;
    result.push(instruction);
  }

  return result;
}

/**
 * Find the instruction at a specific time
 */
export function findInstructionAtTime(
  instructions: GCodeInstruction[],
  time: number
): { instruction: GCodeInstruction; index: number; progress: number } | null {
  if (instructions.length === 0) return null;

  for (let i = 0; i < instructions.length; i++) {
    const instruction = instructions[i];
    const startTime = instruction.cumulativeTime;
    const endTime = startTime + instruction.estimatedDuration;

    if (time >= startTime && time < endTime) {
      const progress = instruction.estimatedDuration > 0
        ? (time - startTime) / instruction.estimatedDuration
        : 1;

      return { instruction, index: i, progress };
    }
  }

  // If past all instructions, return the last one
  const lastIndex = instructions.length - 1;
  return {
    instruction: instructions[lastIndex],
    index: lastIndex,
    progress: 1,
  };
}

/**
 * Linear interpolation between two positions
 */
export function lerp(
  start: { x: number; y: number },
  end: { x: number; y: number },
  t: number
): { x: number; y: number } {
  return {
    x: start.x + (end.x - start.x) * t,
    y: start.y + (end.y - start.y) * t,
  };
}

/**
 * Format time in mm:ss format
 */
export function formatTime(ms: number): string {
  const totalSeconds = Math.floor(ms / 1000);
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;
  return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
}
