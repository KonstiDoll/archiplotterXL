/**
 * G-Code Parser for ArchiSlicer Simulator
 *
 * Parses G-Code generated by ArchiSlicer and converts it to
 * a sequence of instructions for the simulator.
 *
 * Coordinate System:
 * - Machine: X is vertical (up), Y is horizontal (right)
 * - Slicer/Canvas: X is horizontal (right), Y is vertical (up)
 * - Transformation: Canvas X = Machine Y, Canvas Y = Machine X
 */

import type {
  GCodeInstruction,
  ParsedGCode,
  MachineState,
  ParserWarning,
} from '../types/simulator';
import { createDefaultMachineState } from '../types/simulator';

// Workpiece bounds (for out-of-bounds detection)
const WORKPIECE_MIN_X = 0;
const WORKPIECE_MAX_X = 1210;  // Machine X range
const WORKPIECE_MIN_Y = 0;
const WORKPIECE_MAX_Y = 1864;  // Machine Y range

// Pen threshold: U values below this are considered "pen down"
const PEN_DOWN_THRESHOLD = 20;

// Default feedrate
const DEFAULT_DRAWING_FEEDRATE = 3000;

// Macro data (loaded from public/macros.json)
interface MacroInstruction {
  type: string;
  x?: number;
  y?: number;
  z?: number;
  u?: number;
  feedrate?: number;
  isRelative?: boolean;
}

interface MacrosData {
  version: string;
  macros: Record<string, {
    raw: string[];
    flattened: MacroInstruction[];
  }>;
}

let macrosData: MacrosData | null = null;
let macrosLoadPromise: Promise<MacrosData | null> | null = null;

/**
 * Load macros data from public/macros.json
 */
async function loadMacros(): Promise<MacrosData | null> {
  if (macrosData) return macrosData;
  if (macrosLoadPromise) return macrosLoadPromise;

  macrosLoadPromise = fetch('/macros.json')
    .then(res => {
      if (!res.ok) throw new Error(`Failed to load macros: ${res.status}`);
      return res.json();
    })
    .then(data => {
      macrosData = data;
      return data;
    })
    .catch(err => {
      console.warn('Could not load macros.json:', err);
      return null;
    });

  return macrosLoadPromise;
}

// Pre-load macros on module init
loadMacros();

/**
 * Parse a G-Code string into a structured format for the simulator
 */
export async function parseGCode(gcode: string): Promise<ParsedGCode> {
  // Ensure macros are loaded
  await loadMacros();
  const lines = gcode.split('\n');
  const instructions: GCodeInstruction[] = [];

  // Machine state tracking during parsing
  const state = createDefaultMachineState();

  // Statistics
  let totalDrawingLength = 0;
  let totalTravelLength = 0;
  let pumpCount = 0;
  let drawingMoves = 0;
  let travelMoves = 0;

  // Bounds tracking
  let minX = Infinity, maxX = -Infinity;
  let minY = Infinity, maxY = -Infinity;

  // Tool tracking
  const toolsUsed = new Set<number>();

  // Cumulative time tracking
  let cumulativeTime = 0;

  // Pump detection state
  let inPumpSequence = false;

  // Warnings and errors
  const warnings: ParserWarning[] = [];

  for (let i = 0; i < lines.length; i++) {
    const lineNumber = i + 1;
    const rawLine = lines[i].trim();

    // Skip empty lines
    if (!rawLine) continue;

    // Parse the line (may return multiple instructions for macros)
    const parsedInstructions = parseLine(rawLine, lineNumber, state, warnings);

    if (parsedInstructions.length === 0) continue;

    // Process each instruction from the parsed line
    for (const instruction of parsedInstructions) {
      // Handle pump sequence detection (G91 followed by Z moves, then G90)
      if (instruction.type === 'set_mode') {
        if (instruction.rawLine.includes('G91')) {
          inPumpSequence = true;
        } else if (instruction.rawLine.includes('G90') && inPumpSequence) {
          inPumpSequence = false;
        }
      }

      // Detect pump action (Z moves in relative mode)
      if (inPumpSequence && instruction.type === 'move' && instruction.z !== undefined) {
        instruction.type = 'pump';
        instruction.pumpHeight = Math.abs(instruction.z);
        pumpCount++;
      }

      // Update machine state and calculate timing
      const duration = calculateDuration(instruction, state);
      instruction.estimatedDuration = duration;
      instruction.cumulativeTime = cumulativeTime;
      cumulativeTime += duration;

      // Track start/end positions for moves
      if (instruction.type === 'move' || instruction.type === 'pump') {
        instruction.startPosition = { x: state.position.x, y: state.position.y };

        // Update position
        if (instruction.x !== undefined) {
          state.position.x = state.absoluteMode ? instruction.x : state.position.x + instruction.x;
        }
        if (instruction.y !== undefined) {
          state.position.y = state.absoluteMode ? instruction.y : state.position.y + instruction.y;
        }
        if (instruction.z !== undefined) {
          state.position.z = state.absoluteMode ? instruction.z : state.position.z + instruction.z;
        }

        instruction.endPosition = { x: state.position.x, y: state.position.y };

        // Check for out-of-bounds (only for non-macro moves to tool area)
        if (!instruction.isMacroMove) {
          const x = state.position.x;
          const y = state.position.y;
          if (x < WORKPIECE_MIN_X || x > WORKPIECE_MAX_X ||
              y < WORKPIECE_MIN_Y || y > WORKPIECE_MAX_Y) {
            warnings.push({
              type: 'warning',
              lineNumber: instruction.lineNumber,
              message: 'Bewegung außerhalb des Arbeitsbereichs',
              details: `Position (${x.toFixed(1)}, ${y.toFixed(1)}) liegt außerhalb von (${WORKPIECE_MIN_X}-${WORKPIECE_MAX_X}, ${WORKPIECE_MIN_Y}-${WORKPIECE_MAX_Y})`,
            });
          }
        }

        // Calculate distance for statistics
        if (instruction.startPosition && instruction.endPosition) {
          const dx = instruction.endPosition.x - instruction.startPosition.x;
          const dy = instruction.endPosition.y - instruction.startPosition.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (instruction.isTravel) {
            totalTravelLength += distance;
            travelMoves++;
          } else if (instruction.type === 'move') {
            totalDrawingLength += distance;
            drawingMoves++;
          }
        }

        // Update bounds (convert machine coords to canvas coords)
        const canvasX = state.position.y; // Machine Y → Canvas X
        const canvasY = state.position.x; // Machine X → Canvas Y
        if (canvasX < minX) minX = canvasX;
        if (canvasX > maxX) maxX = canvasX;
        if (canvasY < minY) minY = canvasY;
        if (canvasY > maxY) maxY = canvasY;
      }

      // Handle pen up/down
      if (instruction.type === 'pen_up') {
        state.isPenDown = false;
        state.position.u = instruction.u ?? 33;
      } else if (instruction.type === 'pen_down') {
        state.isPenDown = true;
        state.position.u = instruction.u ?? 13;
      }

      // Handle tool changes
      if (instruction.type === 'tool_change' && instruction.toolNumber !== undefined) {
        if (instruction.isGrab) {
          state.currentTool = instruction.toolNumber;
          toolsUsed.add(instruction.toolNumber);
        } else {
          state.currentTool = null;
        }
      }

      // Handle mode changes
      if (instruction.type === 'set_mode') {
        state.absoluteMode = instruction.rawLine.includes('G90');
      }

      // Update feedrate
      if (instruction.feedrate !== undefined) {
        state.feedrate = instruction.feedrate;
      }

      // Mark travel moves
      if (instruction.type === 'move') {
        instruction.isTravel = !state.isPenDown;
      }

      instructions.push(instruction);
    } // End of instruction loop
  } // End of line loop

  // Handle edge case for bounds
  if (minX === Infinity) minX = 0;
  if (maxX === -Infinity) maxX = 1864;
  if (minY === Infinity) minY = 0;
  if (maxY === -Infinity) maxY = 1210;

  return {
    instructions,
    totalDuration: cumulativeTime,
    bounds: { minX, maxX, minY, maxY },
    toolChanges: Array.from(toolsUsed).sort((a, b) => a - b),
    statistics: {
      totalMoves: drawingMoves + travelMoves,
      drawingMoves,
      travelMoves,
      totalDrawingLength: Math.round(totalDrawingLength * 10) / 10,
      totalTravelLength: Math.round(totalTravelLength * 10) / 10,
      pumpCount,
    },
    warnings,
  };
}

/**
 * Parse a single G-Code line
 * Returns an array of instructions (usually 1, but macros expand to multiple)
 */
function parseLine(
  rawLine: string,
  lineNumber: number,
  state: MachineState,
  warnings: ParserWarning[]
): GCodeInstruction[] {
  // Comment line
  if (rawLine.startsWith(';')) {
    return [{
      type: 'comment',
      lineNumber,
      rawLine,
      estimatedDuration: 0,
      cumulativeTime: 0,
    }];
  }

  // Remove inline comments
  const line = rawLine.split(';')[0].trim();
  if (!line) return [];

  // G90 - Absolute positioning
  if (line === 'G90') {
    return [{
      type: 'set_mode',
      lineNumber,
      rawLine,
      estimatedDuration: 0,
      cumulativeTime: 0,
    }];
  }

  // G91 - Relative positioning
  if (line === 'G91') {
    return [{
      type: 'set_mode',
      lineNumber,
      rawLine,
      estimatedDuration: 0,
      cumulativeTime: 0,
    }];
  }

  // G21 - Millimeter units (ignore, we always use mm)
  if (line === 'G21') {
    return [];
  }

  // M400 - Wait for moves to finish (ignore for simulation)
  if (line === 'M400') {
    return [];
  }

  // G0 - Rapid move (maximum speed)
  if (line.startsWith('G0')) {
    const instr = parseG1(line, lineNumber, rawLine, state);
    instr.isRapid = true;
    // G0 uses maximum feedrate if none specified
    if (instr.feedrate === undefined) {
      instr.feedrate = 15000; // Machine max rapid speed
    }
    return [instr];
  }

  // G1 - Linear move
  if (line.startsWith('G1')) {
    return [parseG1(line, lineNumber, rawLine, state)];
  }

  // M98 - Macro call (tool change) - returns array of expanded instructions
  if (line.startsWith('M98')) {
    return parseM98(line, lineNumber, rawLine, state, warnings);
  }

  // G29 - Mesh compensation (ignore for simulation)
  if (line.startsWith('G29')) {
    return [];
  }

  // Unknown command - add warning
  warnings.push({
    type: 'warning',
    lineNumber,
    message: 'Unbekannter G-Code Befehl',
    details: line,
  });

  return [{
    type: 'unknown',
    lineNumber,
    rawLine,
    estimatedDuration: 0,
    cumulativeTime: 0,
  }];
}

/**
 * Parse a G1 linear move command
 */
function parseG1(
  line: string,
  lineNumber: number,
  rawLine: string,
  _state: MachineState
): GCodeInstruction {
  const instruction: GCodeInstruction = {
    type: 'move',
    lineNumber,
    rawLine,
    estimatedDuration: 0,
    cumulativeTime: 0,
  };

  // Parse X coordinate
  const xMatch = line.match(/X(-?\d+\.?\d*)/);
  if (xMatch) {
    instruction.x = parseFloat(xMatch[1]);
  }

  // Parse Y coordinate
  const yMatch = line.match(/Y(-?\d+\.?\d*)/);
  if (yMatch) {
    instruction.y = parseFloat(yMatch[1]);
  }

  // Parse Z coordinate
  const zMatch = line.match(/Z(-?\d+\.?\d*)/);
  if (zMatch) {
    instruction.z = parseFloat(zMatch[1]);
  }

  // Parse U coordinate (pen position)
  const uMatch = line.match(/U(-?\d+\.?\d*)/);
  if (uMatch) {
    const uValue = parseFloat(uMatch[1]);
    instruction.u = uValue;

    // Determine if this is a pen up or pen down move
    if (uValue >= PEN_DOWN_THRESHOLD) {
      instruction.type = 'pen_up';
    } else {
      instruction.type = 'pen_down';
    }
  }

  // Parse feedrate
  const fMatch = line.match(/F(\d+\.?\d*)/);
  if (fMatch) {
    instruction.feedrate = parseFloat(fMatch[1]);
  }

  return instruction;
}

/**
 * Parse an M98 macro call (tool change)
 * Returns array of instructions (the macro expansion + tool_change marker)
 */
function parseM98(
  line: string,
  lineNumber: number,
  rawLine: string,
  state: MachineState,
  warnings: ParserWarning[]
): GCodeInstruction[] {
  const instructions: GCodeInstruction[] = [];

  // Parse macro path
  const pathMatch = line.match(/P"([^"]+)"/);
  if (!pathMatch) {
    warnings.push({
      type: 'error',
      lineNumber,
      message: 'Ungültiger M98 Befehl',
      details: 'Makro-Pfad konnte nicht geparst werden',
    });
    return [{
      type: 'unknown',
      lineNumber,
      rawLine,
      estimatedDuration: 0,
      cumulativeTime: 0,
    }];
  }

  const macroPath = pathMatch[1];
  const macroName = macroPath.replace('/macros/', '');

  // Check if it's a grab_tool or place_tool macro
  let toolNumber: number | undefined;
  let isGrab = false;

  const grabMatch = macroPath.match(/grab_tool_(\d+)/);
  if (grabMatch) {
    toolNumber = parseInt(grabMatch[1], 10);
    isGrab = true;
  }

  const placeMatch = macroPath.match(/place_tool_(\d+)/);
  if (placeMatch) {
    toolNumber = parseInt(placeMatch[1], 10);
    isGrab = false;
  }

  // Expand macro if available
  if (!macrosData?.macros[macroName]) {
    warnings.push({
      type: 'error',
      lineNumber,
      message: `Makro nicht gefunden: ${macroName}`,
      details: `Das Makro "${macroPath}" ist nicht in macros.json vorhanden`,
    });
  } else if (macrosData?.macros[macroName]) {
    const macroInstructions = macrosData.macros[macroName].flattened;
    let isRelative = state.absoluteMode === false;
    let currentFeedrate = state.feedrate;

    for (const instr of macroInstructions) {
      if (instr.type === 'set_mode') {
        isRelative = instr.isRelative ?? false;
        instructions.push({
          type: 'set_mode',
          lineNumber,
          rawLine: isRelative ? 'G91' : 'G90',
          estimatedDuration: 0,
          cumulativeTime: 0,
        });
      } else if (instr.type === 'move') {
        // Create move instruction
        const moveInstr: GCodeInstruction = {
          type: 'move',
          lineNumber,
          rawLine: `; macro: ${macroName}`,
          estimatedDuration: 0, // Will be calculated later
          cumulativeTime: 0,
          isTravel: true, // Tool change moves are always travel
          isMacroMove: true, // Mark as macro-generated
        };

        if (instr.x !== undefined) moveInstr.x = instr.x;
        if (instr.y !== undefined) moveInstr.y = instr.y;
        if (instr.z !== undefined) moveInstr.z = instr.z;
        if (instr.u !== undefined) moveInstr.u = instr.u;
        if (instr.feedrate !== undefined) {
          moveInstr.feedrate = instr.feedrate;
          currentFeedrate = instr.feedrate;
        } else {
          moveInstr.feedrate = currentFeedrate;
        }

        // Skip pure U/Z moves for position animation (only animate X/Y)
        if (instr.x !== undefined || instr.y !== undefined) {
          instructions.push(moveInstr);
        }
      }
    }
  }

  // Only add tool_change instruction if it's actually a grab/place macro
  if (toolNumber !== undefined) {
    const toolChangeInstr: GCodeInstruction = {
      type: 'tool_change',
      lineNumber,
      rawLine,
      estimatedDuration: 500, // Short delay for the actual grab/place
      cumulativeTime: 0,
      toolNumber,
      isGrab,
    };
    instructions.push(toolChangeInstr);
  }

  return instructions;
}

/**
 * Calculate the duration of an instruction in milliseconds
 */
function calculateDuration(
  instruction: GCodeInstruction,
  state: MachineState
): number {
  if (instruction.type === 'tool_change') {
    return 2000; // Tool changes take ~2 seconds
  }

  if (instruction.type === 'pump') {
    return 500; // Pump action takes ~0.5 seconds
  }

  if (instruction.type === 'pen_up' || instruction.type === 'pen_down') {
    return 100; // Pen movements are quick
  }

  if (instruction.type === 'move') {
    // Calculate distance
    let dx = 0, dy = 0;

    if (instruction.x !== undefined) {
      const targetX = state.absoluteMode ? instruction.x : state.position.x + instruction.x;
      dx = targetX - state.position.x;
    }

    if (instruction.y !== undefined) {
      const targetY = state.absoluteMode ? instruction.y : state.position.y + instruction.y;
      dy = targetY - state.position.y;
    }

    const distance = Math.sqrt(dx * dx + dy * dy);

    // Get feedrate (mm/min)
    const feedrate = instruction.feedrate ?? state.feedrate ?? DEFAULT_DRAWING_FEEDRATE;

    // Calculate time: distance (mm) / feedrate (mm/min) * 60000 (ms/min)
    if (feedrate > 0 && distance > 0) {
      return (distance / feedrate) * 60000;
    }
  }

  return 0;
}

/**
 * Get instructions up to a specific time
 */
export function getInstructionsUpToTime(
  instructions: GCodeInstruction[],
  time: number
): GCodeInstruction[] {
  const result: GCodeInstruction[] = [];

  for (const instruction of instructions) {
    if (instruction.cumulativeTime > time) break;
    result.push(instruction);
  }

  return result;
}

/**
 * Find the instruction at a specific time
 */
export function findInstructionAtTime(
  instructions: GCodeInstruction[],
  time: number
): { instruction: GCodeInstruction; index: number; progress: number } | null {
  if (instructions.length === 0) return null;

  for (let i = 0; i < instructions.length; i++) {
    const instruction = instructions[i];
    const startTime = instruction.cumulativeTime;
    const endTime = startTime + instruction.estimatedDuration;

    if (time >= startTime && time < endTime) {
      const progress = instruction.estimatedDuration > 0
        ? (time - startTime) / instruction.estimatedDuration
        : 1;

      return { instruction, index: i, progress };
    }
  }

  // If past all instructions, return the last one
  const lastIndex = instructions.length - 1;
  return {
    instruction: instructions[lastIndex],
    index: lastIndex,
    progress: 1,
  };
}

/**
 * Linear interpolation between two positions
 */
export function lerp(
  start: { x: number; y: number },
  end: { x: number; y: number },
  t: number
): { x: number; y: number } {
  return {
    x: start.x + (end.x - start.x) * t,
    y: start.y + (end.y - start.y) * t,
  };
}

/**
 * Format time in mm:ss format
 */
export function formatTime(ms: number): string {
  const totalSeconds = Math.floor(ms / 1000);
  const minutes = Math.floor(totalSeconds / 60);
  const seconds = totalSeconds % 60;
  return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
}
